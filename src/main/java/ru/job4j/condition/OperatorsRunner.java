package ru.job4j.condition;

public class OperatorsRunner {
    public static void main(String[] args) {
        int first = 2;
        int second = 10;
        int result = first + second;
        System.out.println("Result sun: " + result);
        result = second - first;
        System.out.println(("Result subtract: " + result));
        result = first * second;
        System.out.println("Result multiply: " + result);
        result = second / first;
        System.out.println("Result divide: " + result);

        //Теперь разберем такой математический оператор, как остаток от деления – он обозначается знаком процента.
        //
        //Остаток от деления – это особый оператор, который позволяет разделить левое число в выражении на правое и получить остаток от этого деления. Если эти числа делятся друг на друга без остатка, то остаток от деления равен 0.
        //
        //Разберем несколько примеров:
        System.out.println("Remainder after division: " + second % first);
        second = 7;
        System.out.println("Remainder after division: " + second % first);
        second = 55;
        first = 15;
        System.out.println("Remainder after division: " + second % first);

        // Оператор вычисления остатка от деления достаточно часто встречается в задачах и может сильно упростить задачу разбиения чисел на составляющие. Обратите внимание на него и запомните его. Приведем небольшой пример:
        int i = 1234;
        int thousands = i / 1000;
        int hundreds = i % 1000 / 100;
        int tens = i % 1000 % 100 / 10;
        int ones = i % 1000 % 100 % 10;
        System.out.println("Thousands: " + thousands + ", Hundreds: " + hundreds + ", Tens: " + tens + ", Ones: " + ones);
        //Т.е. таким образом мы разбиваем поразрядно наше исходное число на составляющие и узнаем сколько тысяч, сотен десятков и единиц составляют наше исходное число.

        //Особый интерес для нас составляют такие математические операторы как инкремент и декремент – обозначают как сдвоенные плюсы “++” и минусы “--” соответственно.
        //Разберемся что это за операторы на основании следующего кода:
        int s = 100;
        System.out.println("S.Before increment: " + s);
        s++;
        System.out.println("After increment: " + s);
        s--;
        System.out.println("After decrement: " + s);
        //Т.е. все что делают эти математические операторы, это увеличивают или уменьшают на 1 единицу значение нашей переменной.
        //
        //Представленный выше код может быть переписан в следующем виде и выполнять он будет тот же функционал:
        int r = 100;
        System.out.println("R.Before increment: " + r);
        r = r + 1;
        System.out.println("After increment: " + r);
        r = r - 1;
        System.out.println("After decrement: " + r);
        //Важно отметить, что запись операторов инкремент и декремента возможна в двух формах:
        //
        //- преинкремент и предекремент (операторы ставятся до нашей переменной);
        //
        //- постинкремент и постдекремент (операторы ставятся после нашей переменной);
        //
        //На этом мы остановимся немного подробнее, чтобы разобраться в разнице работы этих записей. Рассмотрим следующий небольшой пример:
        int q = 100;
        System.out.println("Q.Use increment: " + q++);
        System.out.println("After increment: " + q);
        System.out.println("Use decrement: " + q--);
        System.out.println("After decrement: " + q);
        //Обратите внимание на последовательность действий:
        //
        //- сначала мы делаем инкремент, однако в консоль выводится все равно число 100;
        //
        //- далее мы просто выводим нашу переменную и в консоли мы уже получаем обновленное значение 101;
        //
        //- далее выполняется декремент, но при этом в консоль все равно выводится 101;
        //
        //- в конце выводим значение переменной – оно возвращается в исходное значение 100.
        //
        //В этом и состоит особенность поведения данного оператора – здесь и сейчас будет использовано текущее значение переменной и только далее по коду мы будем использовать обновленное значение этой переменной (увеличенное или уменьшенное на одну единицу).
        //
        //Теперь рассмотрим в чем отличия работы пре-форм от пост-форм записи операторов инкремента и декремента. Используем следующий код:
        int w = 100;
        System.out.println("W.Before increment: " + w);
        System.out.println("Use increment: " + ++w);
        System.out.println("Before decrement: " + w);
        System.out.println("Use decrement: " + --w);
        //Обратите внимание на последовательность действий:
        //
        //- сначала мы выполняем вывод исходного значения переменной 100;
        //
        //- далее мы выполняем преинкремент и выводим результат на консоль и сразу получаем значение 101;
        //
        //- далее мы выводим значение перед выполнением декремента – получаем 101;
        //
        //- в конце выполняем предекремент и выводим в консоль – получаем сразу значение 100 в консоли.
        //
        //В этом и есть отличие в поведении пре-форм и пост-форм инкремента и декремента – первый сразу использует обновленное значение, и мы видели на экране, а второй – использует текущее значение и только потом его обновляет. Об этой важной особенности необходимо знать.
        //
        //В курсе мы рекомендуем не использовать пре-формы инкремента и декремента, поскольку они усложняют чтение и понимание работы кода. Однако, знать про их существование достаточно важно.

        //Мы постоянно в коде используем оператор присваивания “=”. Однако помимо них существует набор так называемых составных операторов присваивания и имеют они следующий вид:
        //
        //- += - выполняет суммирование правого значения к левому и присваивает результат левому значению;
        //
        //- -= - выполняет вычитание правого значения из левого и присваивает результат вычисления левому значению;
        //
        //- *= - выполняет умножение правого значения из левого и присваивает результат вычисления левому значению;
        //
        //- /= - выполняет деление левого значения на правое и присваивает результат вычисления левому значению;
        //
        //- %= - вычисляет остаток от деления левого значения на правое и присваивает результат вычисления левому значению.
        //
        //Перепишем ранее реализованный код:
        int first1 = 2;
        int second1 = 10;
        int result1 = first1 + second1;
        System.out.println("Result sum: " + result1);
        result1 = second1 - first1;
        System.out.println("Result subtract: " + result1);
        result1 = first1 * second1;
        System.out.println("Result multiply: " + result1);
        result1 = second1 / first1;
        System.out.println("Result divide: " + result1);

        int first2 = 2;
        int second2 = 10;
        first2 += second2;
        System.out.println("Result sum: " + first2);
        first2 = 2;
        second2 -= first2;
        System.out.println("Result subtract: " + second2);
        second2 = 10;
        first2 *= second2;
        System.out.println("Result multiply: " + first2);
        first2 = 2;
        second2 /= first2;
        System.out.println("Result divide: " + second2);
        //Можете сравнить выводы в задании и убедиться в том, что вывод в консоль не изменился.
        //
        //Наверное, вы обратили внимание, что мы в коде при использовании составных операторов присваивания мы часто переназначали переменную first или second – связано это с тем, что при использовании операторов мы переназначаем значение левой от знака присваивания переменной. Важно помнить об этом.
        //
        //Также стоит помнить одну очень важную особенность поведения составных операторов присваивания. Если типы значений с двух сторон от знака присваивания имеют разные типы данных, то результат вычисления будет приведен к тому типу, который у нас стоит слева от знака присваивания.

        //Представим, что у нас есть следующий код:
        // int one = 10;
        // double two = 100.0;
        //int result3 = one + two;
        //и если вы скопируете этот код в IntelliJ Idea, то вы получите ошибку компиляции.
        //Т.е. Java не может автоматически выполнить преобразование результат вычисления суммы двух чисел разного типа в типу int. Согласно правилам приведения результат вычисления суммы будет иметь тип double, то чтобы перейти к типу int необходимо выполнить явное приведение типов, т.е. код необходимо выразить следующим образом:
        int one = 10;
        double two = 100.0;
        int result3 = (int) (one + two);
        //Однако код можно записать проще, в соответствии с особенностью, представленной выше:
        int one1 = 10;
        double two1 = 100.0;
        one1 += two1;
        //Такой код работает без явного приведения типов, на выходе мы получим тип int.
        //
        //Также операторы инкремента и декремента можно записать с использованием составных операторов присваивания:
        int y = 10;
        y = y + 1;
        y += 1;
        y++;
        //т.е. все три представленные строки выполняют одно и то же действие – увеличивают переменную y на 1.
        //
        //Небольшие выводы:
        //
        //1. Существуют различные математические операторы, которые позволяют вычислить сумму, разность, произведение, деление и остаток от деления;
        //
        //2. Существуют операторы инкремента (увеличение на 1) и декремента (уменьшение на 1) в пре-форме и пост-форме. Старайтесь использовать только пост-форму;
        //
        //3. В коде можно использовать составные операторы присваивания, которые сразу и вычисляют, и записывают результат вычисления в переменную, которая стоит слева от знака присваивания.
        //
        //4. Если значения слева и справа от знака присваивания имеют разный тип данных, то результат вычисления будет приведен к тому типу, который имеет то значение, которое стоит слева от знака присваивания.
    }
}
